<html><head>
    <title>UFO Sightings</title>
    <head>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    </head>
    <div id="my_dataviz"></div>
    
    
      <script id="lollipopchart">
    

      
      var margin = {top: 10, right: 30, bottom: 30, left: 60}
      var width = 460-margin.left-margin.right;
      var height = 400 - margin.top - margin.bottom;
      

      //var radius = Math.min(width, height)/2 - margin;

      var svg = d3.select("#my_dataviz")
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      
      const requestData = async function() {
       
        const UFO = await d3.csv("./scrubbed.csv", d3.autoType);
        
        
        let dataList = [];
        //gets important data that we care about from data file
        UFO.forEach( d => {
          
          var temp = {
            "Shape": d.shape,
            "Country": d.country,
            "Year": d.datetime.split(" ")[0].split("/")[2],
            "Month": d.datetime.split(" ")[0].split("/")[0],
            "Day": d.datetime.split(" ")[0].split("/")[1],
            "Comments": d.comments
          }; 

          dataList.push(temp);

        });

        function getShapes(UFOdata){
        let shapes = []; 
        for (var i = 0; i<UFOdata.length; i++){
          var shape = UFOdata[i]["Shape"];
          if (!(shape in shapes)) {
            shapes.push(shape);
          } 
        };
        return shapes; 
      }

      function getShapeFrequency(UFOdata){
          let shapeFreq = {}; 
          for (var i = 0; i<UFOdata.length; i++){
            var shape = UFOdata[i]["Shape"];
            if (shape in shapeFreq) {
              shapeFreq[shape] +=1;
            } else {
              shapeFreq[shape] = 1;
            }
          };
          return shapeFreq; 
        }
      
      function getShapeYears(UFOdata){
          let shapeYears = []; 
          for (var i = 0; i<UFOdata.length; i++){
            var year = UFOdata[i]["Year"];
            if (!(year in shapeYears)) {
              shapeYears.push(year);
          };
          return shapeYears; 
          }
      }

      
      //NEED TO FIND OUT NUMBER OF EACH SHAPE PER YEAR??
      // function getShapesPerYear(UFOdata){
      //     let shapesPerYear = {}; 
      //     for (var i = 0; i<UFOdata.length; i++){
      //       var year = UFOdata[i]["Year"];
      //       if (year in shapesPerYear) {
      //         shapeYears.push(year);
      //     };
      //     return shapeYears; 
      //     }
      // }
      
      var shapeYears = getShapeYears(dataList); 
      var minYear = Math.min(shapeYears);
      var maxYear = Math.max(shapeYears); 

      var shapeFrequency = getShapeFrequency(dataList); 
      var keys = Object.keys(shapeFrequency);
      var minShapeNum = Math.min.apply(null, keys.map(function(x) { return shapeFrequency[x]} ));
      var maxShapeNum = Math.max.apply(null, keys.map(function(x) { return shapeFrequency[x]} ));
      // var keys = Object.keys(shapeYears);
      // var minYear = Math.min.apply(null, keys.map(function(x) { return shapeYears[x]} ));
      // var maxYear = Math.max.apply(null, keys.map(function(x) { return shapeYears[x]} ));

      var data = getShapeFrequency(dataList);
        // var color = d3.scaleOrdinal()
        //               .domain(["changing", "chevron", "cigar", "circle", "cone", "cross", "cylinder", "diamond"])
        //               .range(d3.schemeCategory20);
        // var pie = d3.pie()
        //             .sort(null) // Do not sort group by size
        //             .value(function(d) {return d.value; })
        // var data_ready = pie(d3.entries(data))
        // var arc = d3.arc()
        //             .innerRadius(radius * 0.5)         // This is the size of the donut hole
        //             .outerRadius(radius * 0.8)
        var x = d3.scaleLinear()
          .domain([minYear, maxYear])
          .range([0, width]);
        svg.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x).tickArguments([1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020])); 
          // .selectALl("text")
          //   .attr("transform", "translate(-10,0)rotate(-45")
          //   .style("test-anchor", "end");
        
        var y = d3.scaleLinear()
          .range([height, 0])
          .domain([minShapeNum, maxShapeNum]) //unsure
        svg.append("g")
          .call(d3.axisLeft(y)); 

        var shapes = getShapes(dataList); 
        var color = d3.scaleOrdinal()
          .domain(shapes)
          .range(['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999', '#8db0b8', '#ebd8d9', '#8b10f5', '#cab95f', '#545db5', '#f865f3', '#ac8975', '#011bbb', '#2fd174', '#6c5af4', '#4b0678', '#4e869e', '#3e0d4b', '#654f85', '#f34f8c', '#898300', '#aa087b', '#1e675d', '#46a2fc', '#75957f'])

        svg.selectAll(".line")
            .data(data)
            .enter()
            .append("path")
              .attr("fill" , "none")
              .attr("stroke", function(d){return color(d.data.key)})
              .attr("d", function(d) {
                return d3.line()
                  .x(function(d){return x(d.data.year); })
                  .y(function(d) {return y(shapeFrequency[d.data]); })
                  //(d.data.values)
            })
      
        // svg.seletAll("myline")
        //   .data(dataList) //unsure
        //   .enter()
        //   .append("line")
        //     .attr("x1", function(d) {return x(d.year);}) //unsure
        //     .attr("x2", x(0))
        //     .attr("y1", function(d) {return y(d.shape);}) //unsure
        //     .attr("y2", function(d) {return y(d.shape);}) //unsure
        //     .attr("stroke", "grey")

        // svg.selectAll("mycircle")
        //   .data(UFO)
        //   .enter()
        //   .append("circle")
        //     .attr("cx", function(d) { return x(d.year); }) //unsure
        //     .attr("cy", function(d) {return y(d.shape); }) //unsure
        //     .attr("r", "7")
        //     .style("fill", "#69b3a2")
        //     .attr("stroke", "black")
// Another arc that won't be drawn. Just for labels positioning
        // var outerArc = d3.arc()
        //                  .innerRadius(radius * 0.9)
        //                  .outerRadius(radius * 0.9)

// Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
// svg.selectAll('allSlices')
//   .data(data_ready)
//   .enter()
//   .append('path')
//   .attr('d', arc)
//   .attr('fill', function(d){ return(color(d.data.key)) })
//   .attr("stroke", "white")
//   .style("stroke-width", "2px")
//   .style("opacity", 0.7)

// Add the polylines between chart and labels:
  // svg.selectAll('allPolylines')
  // .data(data_ready)
  // .enter()
  // .append('polyline')
  //   .attr("stroke", "black")
  //   .style("fill", "none")
  //   .attr("stroke-width", 1)
  //   .attr('points', function(d) {
  //     var posA = arc.centroid(d) // line insertion in the slice
  //     var posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
  //     var posC = outerArc.centroid(d); // Label position = almost the same as posB
  //     var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
  //     posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
  //     return [posA, posB, posC]
  //   })

// Add the polylines between chart and labels:
  // svg.selectAll('allLabels')
  // .data(data_ready)
  // .enter()
  // .append('text')
  //   .text( function(d) { console.log(d.data.key) ; return d.data.key } )
  //   .attr('transform', function(d) {
  //       var pos = outerArc.centroid(d);
  //       var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
  //       pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
  //       return 'translate(' + pos + ')';
  //   })
  //   .style('text-anchor', function(d) {
  //       var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
  //       return (midangle < Math.PI ? 'start' : 'end')
  //   })

        //console.log(dataList); 
        //gets number of sightings per shape (~29 or 30) 
        function getShapeFrequency(UFOdata){
          let shapeFreq = {}; 
          for (var i = 0; i<UFOdata.length; i++){
            var shape = UFOdata[i]["Shape"];
            if (shape in shapeFreq) {
              shapeFreq[shape] +=1;
            } else {
              shapeFreq[shape] = 1;
            }
          };
          return shapeFreq; 
        }
        //console.log(getShapeFrequency(dataList)); 

        function getShapeFrequencyByCountry(UFOdata, country) {
          let shapeFreq = {};
          for (var i = 0; i<UFOdata.length; i++){
            var nation = UFOdata[i]["Country"];
            if (nation == country){
              var shape = UFOdata[i]["Shape"];
              if (shape in shapeFreq) {
                shapeFreq[shape] += 1;
              } else {
                shapeFreq[shape] = 1;
              }
            } 
          };
          return shapeFreq;
        }

        console.log(getShapeFrequencyByCountry(dataList, "gb")); 
        

      //   function getRandomColor() {
      //       var letters = '0123456789ABCDEF';
      //       var color = '#';
      //       for (var i = 0; i < 6; i++) {
      //           color += letters[Math.floor(Math.random() * 16)];
      //       }
      //       return color;
      //   }
      //   let colorList = []
      //   // trees.forEach( d => {
      //   //     if (!species.includes(d.qSpecies)) {
      //   //         species.push(d.qSpecies); 
      //   //         colorList.push(getRandomColor()); 
      //   //     }
      //   // }); 


      //   trees.forEach( d => {
      //       if (!caretaker.includes(d.qCaretaker)) {
      //           caretaker.push(d.qCaretaker); 
      //           //colorList.push(getRandomColor()); 
      //       }
      //   }); 

      //   //random colors to fill list to required length, but these points are not noticeable in visualization 
      //   colorList = ["#1a7540", "#1c23eb","#a11b53", "#6ab8cc", "#7c6acc", "#97cc68", "#ede964", "#edbd64", "#ed8d64", "#6472ed", "#ed6464", 
      //   getRandomColor(), getRandomColor(), getRandomColor(), getRandomColor(),getRandomColor(),getRandomColor(),getRandomColor(),
      //   getRandomColor(),getRandomColor(),getRandomColor(),getRandomColor(),getRandomColor()]; 

      //   //console.log(species.length); 
      //   console.log(caretaker.length);

      //   //for fill: function (d) { return colorList.indexOf(d.qSpecies);}

      //   // Draw circles using the Positions we just made
      //   map.selectAll("circle").data(trees)
      //      .join("circle")
      //      .attr("r", function (d) { return d.DBH/10;})
      //      .attr("fill", function (d) { return colorList[caretaker.indexOf(d.qCaretaker)];})
      //      .attr("opacity", 0.4)
      //      .attr("cx", d => d.Position[0])
      //      .attr("cy", d => d.Position[1]);
        
        
        
       }
      requestData();
      
      
      
    
    
    
    
      </script>
    
    
    
    
    
      
    
      </div>
    </body>
    </html>
    