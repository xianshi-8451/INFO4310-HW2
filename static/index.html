<html><head>
    <title>UFO Sightings</title>
    <head>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    </head>
    <div id="my_dataviz"></div>
    
    
      <script id="donutchart">
    
      var width = 450;
      var height = 450;
      var margin = 40;

      var radius = Math.min(width, height)/2 - margin;

      var svg = d3.select("#my_dataviz")
                  .append("svg")
                  .attr("width", width)
                  .attr("height", height)
                  .append("g")
                  .attr("transform", "translate(" + width/2 + "," + height/2 + ")");
      
      const requestData = async function() {
       
        const UFO = await d3.csv("./scrubbed.csv", d3.autoType);
        
        
        let dataList = [];
        //gets important data that we care about from data file
        UFO.forEach( d => {
          
          var temp = {
            "Shape": d.shape,
            "Country": d.country,
            "Year": d.datetime.split(" ")[0].split("/")[2],
            "Month": d.datetime.split(" ")[0].split("/")[0],
            "Day": d.datetime.split(" ")[0].split("/")[1],
            "Comments": d.comments
          }; 

          dataList.push(temp);

        });
        var data = getShapeFrequency(dataList);
        var color = d3.scaleOrdinal()
                      .domain(["changing", "chevron", "cigar", "circle", "cone", "cross", "cylinder", "diamond"])
                      .range(d3.schemeCategory20);
        var pie = d3.pie()
                    .sort(null) // Do not sort group by size
                    .value(function(d) {return d.value; })
        var data_ready = pie(d3.entries(data))
        var arc = d3.arc()
                    .innerRadius(radius * 0.5)         // This is the size of the donut hole
                    .outerRadius(radius * 0.8)

// Another arc that won't be drawn. Just for labels positioning
        var outerArc = d3.arc()
                         .innerRadius(radius * 0.9)
                         .outerRadius(radius * 0.9)

// Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
svg.selectAll('allSlices')
  .data(data_ready)
  .enter()
  .append('path')
  .attr('d', arc)
  .attr('fill', function(d){ return(color(d.data.key)) })
  .attr("stroke", "white")
  .style("stroke-width", "2px")
  .style("opacity", 0.7)

// Add the polylines between chart and labels:
  svg.selectAll('allPolylines')
  .data(data_ready)
  .enter()
  .append('polyline')
    .attr("stroke", "black")
    .style("fill", "none")
    .attr("stroke-width", 1)
    .attr('points', function(d) {
      var posA = arc.centroid(d) // line insertion in the slice
      var posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
      var posC = outerArc.centroid(d); // Label position = almost the same as posB
      var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
      posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
      return [posA, posB, posC]
    })

// Add the polylines between chart and labels:
  svg.selectAll('allLabels')
  .data(data_ready)
  .enter()
  .append('text')
    .text( function(d) { console.log(d.data.key) ; return d.data.key } )
    .attr('transform', function(d) {
        var pos = outerArc.centroid(d);
        var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
        pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
        return 'translate(' + pos + ')';
    })
    .style('text-anchor', function(d) {
        var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
        return (midangle < Math.PI ? 'start' : 'end')
    })

        //console.log(dataList); 
        //gets number of sightings per shape (~29 or 30) 
        function getShapeFrequency(UFOdata){
          let shapeFreq = {}; 
          for (var i = 0; i<UFOdata.length; i++){
            var shape = UFOdata[i]["Shape"];
            if (shape in shapeFreq) {
              shapeFreq[shape] +=1;
            } else {
              shapeFreq[shape] = 1;
            }
          };
          return shapeFreq; 
        }
        //console.log(getShapeFrequency(dataList)); 

        function getShapeFrequencyByCountry(UFOdata, country) {
          let shapeFreq = {};
          for (var i = 0; i<UFOdata.length; i++){
            var nation = UFOdata[i]["Country"];
            if (nation == country){
              var shape = UFOdata[i]["Shape"];
              if (shape in shapeFreq) {
                shapeFreq[shape] += 1;
              } else {
                shapeFreq[shape] = 1;
              }
            } 
          };
          return shapeFreq;
        }

        console.log(getShapeFrequencyByCountry(dataList, "gb")); 
        

      //   function getRandomColor() {
      //       var letters = '0123456789ABCDEF';
      //       var color = '#';
      //       for (var i = 0; i < 6; i++) {
      //           color += letters[Math.floor(Math.random() * 16)];
      //       }
      //       return color;
      //   }
      //   let colorList = []
      //   // trees.forEach( d => {
      //   //     if (!species.includes(d.qSpecies)) {
      //   //         species.push(d.qSpecies); 
      //   //         colorList.push(getRandomColor()); 
      //   //     }
      //   // }); 


      //   trees.forEach( d => {
      //       if (!caretaker.includes(d.qCaretaker)) {
      //           caretaker.push(d.qCaretaker); 
      //           //colorList.push(getRandomColor()); 
      //       }
      //   }); 

      //   //random colors to fill list to required length, but these points are not noticeable in visualization 
      //   colorList = ["#1a7540", "#1c23eb","#a11b53", "#6ab8cc", "#7c6acc", "#97cc68", "#ede964", "#edbd64", "#ed8d64", "#6472ed", "#ed6464", 
      //   getRandomColor(), getRandomColor(), getRandomColor(), getRandomColor(),getRandomColor(),getRandomColor(),getRandomColor(),
      //   getRandomColor(),getRandomColor(),getRandomColor(),getRandomColor(),getRandomColor()]; 

      //   //console.log(species.length); 
      //   console.log(caretaker.length);

      //   //for fill: function (d) { return colorList.indexOf(d.qSpecies);}

      //   // Draw circles using the Positions we just made
      //   map.selectAll("circle").data(trees)
      //      .join("circle")
      //      .attr("r", function (d) { return d.DBH/10;})
      //      .attr("fill", function (d) { return colorList[caretaker.indexOf(d.qCaretaker)];})
      //      .attr("opacity", 0.4)
      //      .attr("cx", d => d.Position[0])
      //      .attr("cy", d => d.Position[1]);
        
        
        
       }
      requestData();
      
      
      
    
    
    
    
      </script>
    
    
    
    
    
      
    
      </div>
    </body>
    </html>
    